*******************Maven字符集的设置*********************
<properties>
	<project.build.sourceEncoding>UTF-8</project.build.sourceEncoding>
	<project.reporting.outputEncoding>UTF-8</project.reporting.outputEncoding>
	<java.version>1.8</java.version>
</properties>

//***************************************************
1、修改Maven的配置文件
<!-- 使用JDK1.8进行项目的编译，运行，打包 -->
<profiles>
	<profile>
		<id>jdk1.8</id>
		<activation>
			<activeByDefault>true</activeByDefault>
			<jdk>1.8</jdk>
		</activation>
		<properties>
			<maven.compiler.source>1.8</maven.compiler.source>
			<maven.compiler.target>1.8</maven.compiler.target>
			<maven.compiler.compilerVersion>1.8</maven.compiler.compilerVersion>
		</properties>
	</profile>
</profiles>

//******************************************
2、导入配置文件的方式
	# 属性在主配置文件中
	@Component
	@ConfigurationProperties(prefix = "person")
	public class Person{}
	
	#属性在单独的属性文件中
	@PropertySource(value = {"classpath:person.properties"})
	public class Person{}
	
//*****************************************
3、SpringBoot的自动配置原理：
	1)SpringBoot启动的时候加载主配置类，开启了自动配置功能 @EnableAutoConfiguration
	2)@EnableAutoConfiguration 作用：
	@Import(AutoConfigurationImportSelector.class)
	public @interface EnableAutoConfiguration {
	利用EnableAutoConfigurationImportSelector给容器中导入一些组件
	可以查看selectImports()方法的内容
	SpringFactoriesLoader.loadFactoryNames()
	扫描所有jar包类路径下 META‐INF/spring.factories
	把扫描到的这些文件的内容包装成properties对象
	从properties中获取到EnableAutoConfiguration.class类（类名）对应的值，然后把他们添加在容器
	中。
	
以HttpEncodingAutoConfiguration（Http编码自动配置）为例解释自动配置原理:
	
	/*
	 * 表示这是一个配置类，以前编写的配置文件一样，也可以给容器中添加组件
	 */
	@Configuration
	
	/* 启动指定类的
	 * ConfigurationProperties功能；将配置文件中对应的值和HttpEncodingProperties绑定起来；并把
	 * HttpEncodingProperties加入到ioc容器中
	 */
	@EnableConfigurationProperties(HttpEncodingProperties.class)
	
	/*
	 * Spring底层@Conditional注解（Spring注解版），根据不同的条件，如果
	 * 满足指定的条件，整个配置类里面的配置就会生效； 判断当前应用是否是web应用，如果是，当前配置类生效
	 */
	 @ConditionalOnWebApplication
	
	/*
	 * 判断当前项目有没有这个类CharacterEncodingFilter；SpringMVC中进行乱码解决的过滤器；
	 */
	@ConditionalOnClass(CharacterEncodingFilter.class)
	
	/*
	 * 判断配置文件中是否存在某个配置 spring.http.encoding.enabled；如果不存在，判断也是成立的
	 * 即使我们配置文件中不配置pring.http.encoding.enabled=true，也是默认生效的；
	 */
	@ConditionalOnProperty(prefix = "spring.http.encoding", value = "enabled", matchIfMissing =true)
	public class HttpEncodingAutoConfiguration {
		//他已经和SpringBoot的配置文件映射了
		//只有一个有参构造器的情况下，参数的值就会从容器中拿
		public HttpEncodingAutoConfiguration(HttpEncodingProperties properties) {
			this.properties = properties;
		}
		
		@Bean //给容器中添加一个组件，这个组件的某些值需要从properties中获取
		@ConditionalOnMissingBean(CharacterEncodingFilter.class) //判断容器没有这个组件？
		public CharacterEncodingFilter characterEncodingFilter() {
			CharacterEncodingFilter filter = new OrderedCharacterEncodingFilter();
			filter.setEncoding(this.properties.getCharset().name());
			filter.setForceRequestEncoding(this.properties.shouldForce(Type.REQUEST));
			filter.setForceResponseEncoding(this.properties.shouldForce(Type.RESPONSE));
			return filter;
		}
	}
	
//********************************************
4、日志系统：
	1) 日志门面:
	JCL(Jakarta Commons Logging)、SLF4j、jboss-logging
	日志实现:
	Log4j、JUL、Log4j2、Logback
	
	2) SpringBoot选用 SLF4j 和 Logback
	
	log4j和Logback的两种使用组合:
	1) application --> slf4j-api.jar --> logback-classic.jar,logback-core.jar
	2) application --> slf4j-api.jar --> slf4j-log412.jar,log4j.jar
	
	3) 如何让系统中所有的日志都统一到slf4j：
		1、将系统中其他日志框架先排除出去；
		2、用中间包来替换原有的日志框架；
		3、我们导入slf4j其他的实现。
		
	4) 常用配置（文件默认是每天一份）
	logging.level.com.atguigu=trace
	# logging.path=
	#   不指定路径在当前项目下生成springboot.log日志
	#    可以指定完整的路径；
	# logging.file=G:/springboot.log
	#    在当前磁盘的根路径下创建spring文件夹和里面的log文件夹；使用 spring.log 作为默认文件
	logging.path=/spring/log
	#  在控制台输出的日志的格式
	logging.pattern.console=%d{yyyy‐MM‐dd} [%thread] %‐5level %logger{50} ‐ %msg%n
	#   指定文件中日志输出的格式
	logging.pattern.file=%d{yyyy‐MM‐dd} === [%thread] === %‐5level === %logger{50} ==== %msg%n
	
	5) 使用自定义的日志文件：
	给类路径下放上每个日志框架自己的配置文件即可；SpringBoot就不使用它默认配置的了。
	Logback  -- >  logback-spring.xml  、 logback.xml
	Log4j2   -- >  log4j2-spring.xml or log4j2.xml
	logback-spring.xml：日志框架就不直接加载日志的配置项，由SpringBoot解析日志配置，可以使用SpringBoot
	的高级Profile功能:
	
	<appender name="stdout" class="ch.qos.logback.core.ConsoleAppender">
		<!‐‐
		日志输出格式：
		%d表示日期时间，
		%thread表示线程名，
		%‐5level：级别从左显示5个字符宽度
		%logger{50} 表示logger名字最长50个字符，否则按照句点分割。
		%msg：日志消息，
		%n是换行符
		‐‐>
		<layout class="ch.qos.logback.classic.PatternLayout">
			<springProfile name="dev">
				<pattern>%d{yyyy‐MM‐dd HH:mm:ss.SSS} ‐‐> [%thread] ‐> %‐5level%logger{50} ‐ %msg%n</pattern>
			</springProfile>
			<springProfile name="!dev">
				<pattern>%d{yyyy‐MM‐dd HH:mm:ss.SSS} == [%thread] = %‐5level%logger{50} ‐ %msg%n</pattern>
			</springProfile>
		</layout>
	</appender>
	
	6）如果我们要引入其他框架,一定要把这个框架的默认日志依赖移除掉。
	slf4j+log4j的方式:
	<dependency>
		<groupId>org.springframework.boot</groupId>
		<artifactId>spring-boot-starter-web</artifactId>
		<exclusions>
			<exclusion>
				<artifactId>logback-classic</artifactId>
				<groupId>ch.qos.logback</groupId>
			</exclusion>
			<exclusion>
				<artifactId>log4j-over-slf4j</artifactId>
				<groupId>org.slf4j</groupId>
			</exclusion>
		</exclusions>
	</dependency>
	<dependency>
		<groupId>org.slf4j</groupId>
		<artifactId>slf4j‐log4j12</artifactId>
	</dependency>

	切换为log4j2:
	<dependency>
		<groupId>org.springframework.boot</groupId>
		<artifactId>spring‐boot‐starter‐web</artifactId>
		<exclusions>
			<exclusion>
				<artifactId>spring‐boot‐starter‐logging</artifactId>
				<groupId>org.springframework.boot</groupId>
			</exclusion>
		</exclusions>
	</dependency>
	<dependency>
		<groupId>org.springframework.boot</groupId>
		<artifactId>spring‐boot‐starter‐log4j2</artifactId>
	</dependency>
	
//***********************************************
Web功能：
1、访问首页：
	静态资源文件夹下放置index.html(欢迎页)
2、错误定制
	1）、有模板引擎的情况下；error/状态码; 【将错误页面命名为 错误状态码.html 放在模板引擎文件夹里面的
		error文件夹下】，发生此状态码的错误就会来到 对应的页面。
	2）、没有模板引擎（模板引擎找不到这个错误页面），静态资源文件夹下找；
	3）、以上都没有错误页面，就是默认来到SpringBoot默认的错误提示页面。
3、server的配置：
	1、修改和server有关的配置（ServerProperties）
	org.springframework.boot.autoconfigure.web.ServerProperties
4、注册三大组件用以下方式:
	ServletRegistrationBean
	FilterRegistrationBean
	ServletListenerRegistrationBean
	
嵌入式Servlet容器：应用打成可执行的jar
优点：简单、便携；
缺点：默认不支持JSP、优化定制比较复杂（使用定制器【ServerProperties、自定义EmbeddedServletContainerCustomizer】，
自己编写嵌入式Servlet容器的创建工厂【EmbeddedServletContainerFactory】）。
外置的Servlet容器：外面安装Tomcat---应用war包的方式打包。

5、使用外部的Tomcat:
1)、创建war项目，在 src.main 目录下创建 webapp文件夹，webapp下建WEB-INF文件夹，WEB-INF下建 web.xml文件
	注：main下三个文件夹：java、resources、webapp属同级目录。
2)、pom依赖：
	<dependency>
		<groupId>org.springframework.boot</groupId>
		<artifactId>spring‐boot‐starter‐tomcat</artifactId>
		<scope>provided</scope>
	</dependency>
3)、启动类的修改：
必须编写一个SpringBootServletInitializer的子类，并调用configure方法
public class ServletInitializer extends SpringBootServletInitializer {
	@Override
	protected SpringApplicationBuilder configure(SpringApplicationBuilder application) {
		//传入SpringBoot应用的主程序
		return application.sources(SpringBoot04WebJspApplication.class);
	}
}
4)、配置文件的修改：
	spring.mvc.view.prefix=/WEB-INF/
	spring.mvc.view.suffix=.jsp
	
//-------------------------------------------------------
缓存的使用步骤：
1、开启基于注解的缓存 @EnableCaching
2、标注缓存注解即可：
	@Cacheable
	@CacheEvict
	@CachePut
	
//-------------------------------------------------------
整合Redis的步骤：
1、安装redis：使用docker；
2、引入redis的starter；
	RedisAutoConfiguration 配置类就起作用了...容器中自动注入以下两个Bean
	RedisTemplate<Object, Object>
	StringRedisTemplate
3、配置redis：配置文件中(详细见文档)
	spring.redis.host=118.24.44.169
4、使用：
	@Autowired
	StringRedisTemplate stringRedisTemplate;  //操作k-v都是字符串的

	@Autowired
	RedisTemplate<String,Object> redisTemplate;  //k-v都是对象的

	@Autowired
	RedisTemplate<Object, Employee> empRedisTemplate;


	/**
	 * Redis常见的五大数据类型
	 *  String（字符串）、List（列表）、Set（集合）、Hash（散列）、ZSet（有序集合）
	 *  stringRedisTemplate.opsForValue()[String（字符串）]
	 *  stringRedisTemplate.opsForList()[List（列表）]
	 *  stringRedisTemplate.opsForSet()[Set（集合）]
	 *  stringRedisTemplate.opsForHash()[Hash（散列）]
	 *  stringRedisTemplate.opsForZSet()[ZSet（有序集合）]
	 */
	@Test
	public void test01(){
		//给redis中保存数据
	    stringRedisTemplate.opsForValue().append("msg","hello");
		String msg = stringRedisTemplate.opsForValue().get("msg");
		System.out.println(msg);

		stringRedisTemplate.opsForList().leftPush("mylist","1");
		stringRedisTemplate.opsForList().leftPush("mylist","2");
	}

	//测试保存对象
	@Test
	public void test02(){
		Employee empById = employeeMapper.getEmpById(1);
		默认如果保存对象，使用jdk序列化机制，序列化后的数据保存到redis中
		redisTemplate.opsForValue().set("emp-01",empById);
		1、将数据以json的方式保存
		(1)自己将对象转为json
		(2)redisTemplate默认的序列化规则；改变默认的序列化规则；
			empRedisTemplate.opsForValue().set("emp-01",empById);
	}
5、测试缓存。
默认: ConcurrentMapCacheManager --- > ConcurrentMapCache
原理：CacheManager===Cache 缓存组件来实际给缓存中存取数据
1）、引入redis的starter，容器中保存的是 RedisCacheManager；
原注解：
@Cacheable
@CacheEvict
@CachePut
依然有效，不过是将数据存到了Redis的数据库中。
2）、RedisCacheManager 帮我们创建 RedisCache 来作为缓存组件；RedisCache通过操作redis缓存数据的；
3）、默认保存数据 k-v 都是Object；利用序列化保存；如何保存为json；
1、引入了redis的starter，cacheManager变为 RedisCacheManager；
2、默认创建的 RedisCacheManager 操作redis的时候使用的是 RedisTemplate<Object, Object>；
3、RedisTemplate<Object, Object> 是 默认使用jdk的序列化机制；
4、自定义CacheManager。

//**************************************************************************
异步任务:
1、开启异步任务注解:
2、异步方法上加注解:

//********************************
定时任务的cron 语法:

字段         允许值                             允许的特殊符号	
秒             0-59              , - * /
分             0-59              , - * /
小时 	  0-23 			    , - * /
日期 	  1-31              , - * ? / L W C
月份         1-12               , - * /
星期  0-7或SUN-SAT 0,7是SUN  , - * ? / L C #

特殊字符                  代表含义
,            枚举
-            区间
*            任意
/            步长
?       日/星期冲突匹配
L            最后
W           工作日
C       和calendar联系后计算过的值
#       星期， 4#2，第2个星期四

//*******************************邮件任务
1、引入依赖：
<dependency>
	<groupId>org.springframework.boot</groupId>
	<artifactId>spring-boot-starter-data-mail</artifactId>
</dependency>

2、配置文件中的账户配置:
spring.mail.username=534096094@qq.com
# 第三方登陆的授权码
spring.mail.password=gtstkoszjelabijb
# 发送邮件账号的对应服务器
spring.mail.host=smtp.qq.com
spring.mail.properties.mail.smtp.ssl.enable=true

3、发送代码

@Autowired
JavaMailSenderImpl mailSender;

@Test
public void contextLoads() {
	SimpleMailMessage message = new SimpleMailMessage();
	//邮件设置
	message.setSubject("通知-今晚开会");
	message.setText("今晚7:30开会");

	message.setTo("17512080612@163.com");
	message.setFrom("534096094@qq.com");

	mailSender.send(message);
}

@Test
public void test02() throws  Exception{
	//1、创建一个复杂的消息邮件
	MimeMessage mimeMessage = mailSender.createMimeMessage();
	MimeMessageHelper helper = new MimeMessageHelper(mimeMessage, true);

	//邮件设置
	helper.setSubject("通知-今晚开会");
	helper.setText("<b style='color:red'>今天 7:30 开会</b>",true);

	helper.setTo("17512080612@163.com");
	helper.setFrom("534096094@qq.com");

	//上传文件
	helper.addAttachment("1.jpg",new File("C:\\Users\\lfy\\Pictures\\Saved Pictures\\1.jpg"));
	helper.addAttachment("2.jpg",new File("C:\\Users\\lfy\\Pictures\\Saved Pictures\\2.jpg"));

	mailSender.send(mimeMessage);

}
	
