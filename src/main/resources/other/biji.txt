*******************Maven字符集的设置*********************
<properties>
	<project.build.sourceEncoding>UTF-8</project.build.sourceEncoding>
	<project.reporting.outputEncoding>UTF-8</project.reporting.outputEncoding>
	<java.version>1.8</java.version>
</properties>

//***************************************************
1、修改Maven的配置文件
<!-- 使用JDK1.8进行项目的编译，运行，打包 -->
<profiles>
	<profile>
		<id>jdk1.8</id>
		<activation>
			<activeByDefault>true</activeByDefault>
			<jdk>1.8</jdk>
		</activation>
		<properties>
			<maven.compiler.source>1.8</maven.compiler.source>
			<maven.compiler.target>1.8</maven.compiler.target>
			<maven.compiler.compilerVersion>1.8</maven.compiler.compilerVersion>
		</properties>
	</profile>
</profiles>

//******************************************
2、导入配置文件的方式
	# 属性在主配置文件中
	@Component
	@ConfigurationProperties(prefix = "person")
	public class Person{}
	
	#属性在单独的属性文件中
	@PropertySource(value = {"classpath:person.properties"})
	public class Person{}
	
//*****************************************
3、SpringBoot的自动配置原理：
	1)SpringBoot启动的时候加载主配置类，开启了自动配置功能 @EnableAutoConfiguration
	2)@EnableAutoConfiguration 作用：
	@Import(AutoConfigurationImportSelector.class)
	public @interface EnableAutoConfiguration {
	利用EnableAutoConfigurationImportSelector给容器中导入一些组件
	可以查看selectImports()方法的内容
	SpringFactoriesLoader.loadFactoryNames()
	扫描所有jar包类路径下 META‐INF/spring.factories
	把扫描到的这些文件的内容包装成properties对象
	从properties中获取到EnableAutoConfiguration.class类（类名）对应的值，然后把他们添加在容器
	中。
	
以HttpEncodingAutoConfiguration（Http编码自动配置）为例解释自动配置原理:
	
	/*
	 * 表示这是一个配置类，以前编写的配置文件一样，也可以给容器中添加组件
	 */
	@Configuration
	
	/* 启动指定类的
	 * ConfigurationProperties功能；将配置文件中对应的值和HttpEncodingProperties绑定起来；并把
	 * HttpEncodingProperties加入到ioc容器中
	 */
	@EnableConfigurationProperties(HttpEncodingProperties.class)
	
	/*
	 * Spring底层@Conditional注解（Spring注解版），根据不同的条件，如果
	 * 满足指定的条件，整个配置类里面的配置就会生效； 判断当前应用是否是web应用，如果是，当前配置类生效
	 */
	 @ConditionalOnWebApplication
	
	/*
	 * 判断当前项目有没有这个类CharacterEncodingFilter；SpringMVC中进行乱码解决的过滤器；
	 */
	@ConditionalOnClass(CharacterEncodingFilter.class)
	
	/*
	 * 判断配置文件中是否存在某个配置 spring.http.encoding.enabled；如果不存在，判断也是成立的
	 * 即使我们配置文件中不配置pring.http.encoding.enabled=true，也是默认生效的；
	 */
	@ConditionalOnProperty(prefix = "spring.http.encoding", value = "enabled", matchIfMissing =true)
	public class HttpEncodingAutoConfiguration {
		//他已经和SpringBoot的配置文件映射了
		//只有一个有参构造器的情况下，参数的值就会从容器中拿
		public HttpEncodingAutoConfiguration(HttpEncodingProperties properties) {
			this.properties = properties;
		}
		
		@Bean //给容器中添加一个组件，这个组件的某些值需要从properties中获取
		@ConditionalOnMissingBean(CharacterEncodingFilter.class) //判断容器没有这个组件？
		public CharacterEncodingFilter characterEncodingFilter() {
			CharacterEncodingFilter filter = new OrderedCharacterEncodingFilter();
			filter.setEncoding(this.properties.getCharset().name());
			filter.setForceRequestEncoding(this.properties.shouldForce(Type.REQUEST));
			filter.setForceResponseEncoding(this.properties.shouldForce(Type.RESPONSE));
			return filter;
		}
	}
	
//********************************************
4、日志系统：
	1) 日志门面:
	JCL(Jakarta Commons Logging)、SLF4j、jboss-logging
	日志实现:
	Log4j、JUL、Log4j2、Logback
	
	2) SpringBoot选用 SLF4j 和 Logback
	
	log4j和Logback的两种使用组合:
	1) application --> slf4j-api.jar --> logback-classic.jar,logback-core.jar
	2) application --> slf4j-api.jar --> slf4j-log412.jar,log4j.jar
	
	3) 如何让系统中所有的日志都统一到slf4j：
		1、将系统中其他日志框架先排除出去；
		2、用中间包来替换原有的日志框架；
		3、我们导入slf4j其他的实现。
		
	4) 常用配置（文件默认是每天一份）
	logging.level.com.atguigu=trace
	# logging.path=
	#   不指定路径在当前项目下生成springboot.log日志
	#    可以指定完整的路径；
	# logging.file=G:/springboot.log
	#    在当前磁盘的根路径下创建spring文件夹和里面的log文件夹；使用 spring.log 作为默认文件
	logging.path=/spring/log
	#  在控制台输出的日志的格式
	logging.pattern.console=%d{yyyy‐MM‐dd} [%thread] %‐5level %logger{50} ‐ %msg%n
	#   指定文件中日志输出的格式
	logging.pattern.file=%d{yyyy‐MM‐dd} === [%thread] === %‐5level === %logger{50} ==== %msg%n
	
	5) 使用自定义的日志文件：
	给类路径下放上每个日志框架自己的配置文件即可；SpringBoot就不使用它默认配置的了。
	Logback  -- >  logback-spring.xml  、 logback.xml
	Log4j2   -- >  log4j2-spring.xml or log4j2.xml
	logback-spring.xml：日志框架就不直接加载日志的配置项，由SpringBoot解析日志配置，可以使用SpringBoot
	的高级Profile功能:
	
	<appender name="stdout" class="ch.qos.logback.core.ConsoleAppender">
		<!‐‐
		日志输出格式：
		%d表示日期时间，
		%thread表示线程名，
		%‐5level：级别从左显示5个字符宽度
		%logger{50} 表示logger名字最长50个字符，否则按照句点分割。
		%msg：日志消息，
		%n是换行符
		‐‐>
		<layout class="ch.qos.logback.classic.PatternLayout">
			<springProfile name="dev">
				<pattern>%d{yyyy‐MM‐dd HH:mm:ss.SSS} ‐‐> [%thread] ‐> %‐5level%logger{50} ‐ %msg%n</pattern>
			</springProfile>
			<springProfile name="!dev">
				<pattern>%d{yyyy‐MM‐dd HH:mm:ss.SSS} == [%thread] = %‐5level%logger{50} ‐ %msg%n</pattern>
			</springProfile>
		</layout>
	</appender>
	
	6）如果我们要引入其他框架,一定要把这个框架的默认日志依赖移除掉。
	slf4j+log4j的方式:
	<dependency>
		<groupId>org.springframework.boot</groupId>
		<artifactId>spring-boot-starter-web</artifactId>
		<exclusions>
			<exclusion>
				<artifactId>logback-classic</artifactId>
				<groupId>ch.qos.logback</groupId>
			</exclusion>
			<exclusion>
				<artifactId>log4j-over-slf4j</artifactId>
				<groupId>org.slf4j</groupId>
			</exclusion>
		</exclusions>
	</dependency>
	<dependency>
		<groupId>org.slf4j</groupId>
		<artifactId>slf4j‐log4j12</artifactId>
	</dependency>

	切换为log4j2:
	<dependency>
		<groupId>org.springframework.boot</groupId>
		<artifactId>spring‐boot‐starter‐web</artifactId>
		<exclusions>
			<exclusion>
				<artifactId>spring‐boot‐starter‐logging</artifactId>
				<groupId>org.springframework.boot</groupId>
			</exclusion>
		</exclusions>
	</dependency>
	<dependency>
		<groupId>org.springframework.boot</groupId>
		<artifactId>spring‐boot‐starter‐log4j2</artifactId>
	</dependency>
	
//***********************************************
Web功能：
1、访问首页：
	静态资源文件夹下放置index.html(欢迎页)
2、错误定制
	1）、有模板引擎的情况下；error/状态码; 【将错误页面命名为 错误状态码.html 放在模板引擎文件夹里面的
		error文件夹下】，发生此状态码的错误就会来到 对应的页面。
	2）、没有模板引擎（模板引擎找不到这个错误页面），静态资源文件夹下找；
	3）、以上都没有错误页面，就是默认来到SpringBoot默认的错误提示页面。
	
